/*!
 * qrcode.vue v1.6.2
 * A Vue component for QRCode.
 * Â© 2017-2019 @scopewu(https://github.com/scopewu)
 * MIT License.
 */
!(function(t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? (module.exports = e(
        require('buffer'),
        require('fs'),
        require('util'),
        require('stream'),
        require('zlib'),
        require('assert')
      ))
    : 'function' == typeof define && define.amd
    ? define(['buffer', 'fs', 'util', 'stream', 'zlib', 'assert'], e)
    : ((t = t || self).QrcodeVue = e(
        t.buffer$1,
        t.fs,
        t.util,
        t.stream,
        t.zlib,
        t.assert
      ))
})(this, function(i, s, o, r, v, a) {
  'use strict'
  ;(i = i && i.hasOwnProperty('default') ? i.default : i),
    (s = s && s.hasOwnProperty('default') ? s.default : s),
    (o = o && o.hasOwnProperty('default') ? o.default : o),
    (r = r && r.hasOwnProperty('default') ? r.default : r),
    (v = v && v.hasOwnProperty('default') ? v.default : v),
    (a = a && a.hasOwnProperty('default') ? a.default : a)
  function u() {
    return (
      'function' == typeof Promise &&
      Promise.prototype &&
      Promise.prototype.then
    )
  }
  var e,
    C = i.Buffer,
    n = [
      0,
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706,
    ],
    I = {
      getSymbolSize: function(t) {
        if (!t) throw Error('"version" cannot be null or undefined')
        if (t < 1 || 40 < t)
          throw Error('"version" should be in range from 1 to 40')
        return 4 * t + 17
      },
      getSymbolTotalCodewords: function(t) {
        return n[t]
      },
      getBCHDigit: function(t) {
        for (var e = 0; 0 !== t; ) e++, (t >>>= 1)
        return e
      },
      setToSJISFunction: function(t) {
        if ('function' != typeof t)
          throw Error('"toSJISFunc" is not a valid function.')
        e = t
      },
      isKanjiModeEnabled: function() {
        return void 0 !== e
      },
      toSJIS: function(t) {
        return e(t)
      },
    }
  function t(t, e) {
    return t((e = { exports: {} }), e.exports), e.exports
  }
  var h = t(function(t, r) {
    ;(r.L = { bit: 1 }),
      (r.M = { bit: 0 }),
      (r.Q = { bit: 3 }),
      (r.H = { bit: 2 }),
      (r.isValid = function(t) {
        return t && void 0 !== t.bit && 0 <= t.bit && t.bit < 4
      }),
      (r.from = function(t, e) {
        if (r.isValid(t)) return t
        try {
          return (function(t) {
            if ('string' != typeof t) throw Error('Param is not a string')
            switch (t.toLowerCase()) {
              case 'l':
              case 'low':
                return r.L
              case 'm':
              case 'medium':
                return r.M
              case 'q':
              case 'quartile':
                return r.Q
              case 'h':
              case 'high':
                return r.H
              default:
                throw Error('Unknown EC Level: ' + t)
            }
          })(t)
        } catch (t) {
          return e
        }
      })
  })
  function f() {
    ;(this.buffer = []), (this.length = 0)
  }
  f.prototype = {
    get: function(t) {
      return 1 == ((this.buffer[Math.floor(t / 8)] >>> (7 - (t % 8))) & 1)
    },
    put: function(t, e) {
      for (var r = 0; r < e; r++) this.putBit(1 == ((t >>> (e - r - 1)) & 1))
    },
    getLengthInBits: function() {
      return this.length
    },
    putBit: function(t) {
      var e = Math.floor(this.length / 8)
      e < this.buffer.length || this.buffer.push(0),
        t && (this.buffer[e] |= 128 >>> this.length % 8),
        this.length++
    },
  }
  var l = f
  function c(t) {
    if (!t || t < 1)
      throw Error('BitMatrix size must be defined and greater than 0')
    ;(this.size = t),
      (this.data = new C(t * t)),
      this.data.fill(0),
      (this.reservedBit = new C(t * t)),
      this.reservedBit.fill(0)
  }
  ;(c.prototype.set = function(t, e, r, n) {
    var i = t * this.size + e
    ;(this.data[i] = r), n && (this.reservedBit[i] = !0)
  }),
    (c.prototype.get = function(t, e) {
      return this.data[t * this.size + e]
    }),
    (c.prototype.xor = function(t, e, r) {
      this.data[t * this.size + e] ^= r
    }),
    (c.prototype.isReserved = function(t, e) {
      return this.reservedBit[t * this.size + e]
    })
  var d,
    p,
    g = c,
    _ = t(function(t, a) {
      var s = I.getSymbolSize
      ;(a.getRowColCoords = function(t) {
        if (1 === t) return []
        for (
          var e = 2 + Math.floor(t / 7),
            r = s(t),
            n = 145 === r ? 26 : 2 * Math.ceil((r - 13) / (2 * e - 2)),
            i = [r - 7],
            o = 1;
          o < e - 1;
          o++
        )
          i[o] = i[o - 1] - n
        return i.push(6), i.reverse()
      }),
        (a.getPositions = function(t) {
          for (
            var e = [], r = a.getRowColCoords(t), n = r.length, i = 0;
            i < n;
            i++
          )
            for (var o = 0; o < n; o++)
              (0 === i && 0 === o) ||
                (0 === i && o === n - 1) ||
                (i === n - 1 && 0 === o) ||
                e.push([r[i], r[o]])
          return e
        })
    }),
    m = I.getSymbolSize,
    y = {
      getPositions: function(t) {
        var e = m(t)
        return [[0, 0], [e - 7, 0], [0, e - 7]]
      },
    },
    E = t(function(t, s) {
      s.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7,
      }
      var f = 3,
        a = 3,
        h = 40,
        i = 10
      function o(t, e, r) {
        switch (t) {
          case s.Patterns.PATTERN000:
            return (e + r) % 2 == 0
          case s.Patterns.PATTERN001:
            return e % 2 == 0
          case s.Patterns.PATTERN010:
            return r % 3 == 0
          case s.Patterns.PATTERN011:
            return (e + r) % 3 == 0
          case s.Patterns.PATTERN100:
            return (Math.floor(e / 2) + Math.floor(r / 3)) % 2 == 0
          case s.Patterns.PATTERN101:
            return ((e * r) % 2) + ((e * r) % 3) == 0
          case s.Patterns.PATTERN110:
            return (((e * r) % 2) + ((e * r) % 3)) % 2 == 0
          case s.Patterns.PATTERN111:
            return (((e * r) % 3) + ((e + r) % 2)) % 2 == 0
          default:
            throw Error('bad maskPattern:' + t)
        }
      }
      ;(s.isValid = function(t) {
        return null != t && '' !== t && !isNaN(t) && 0 <= t && t <= 7
      }),
        (s.from = function(t) {
          return s.isValid(t) ? parseInt(t, 10) : void 0
        }),
        (s.getPenaltyN1 = function(t) {
          for (
            var e = t.size, r = 0, n = 0, i = 0, o = null, a = null, s = 0;
            s < e;
            s++
          ) {
            ;(n = i = 0), (o = a = null)
            for (var h = 0; h < e; h++) {
              var u = t.get(s, h)
              u === o ? n++ : (n < 5 || (r += f + (n - 5)), (o = u), (n = 1)),
                (u = t.get(h, s)) === a
                  ? i++
                  : (i < 5 || (r += f + (i - 5)), (a = u), (i = 1))
            }
            n < 5 || (r += f + (n - 5)), i < 5 || (r += f + (i - 5))
          }
          return r
        }),
        (s.getPenaltyN2 = function(t) {
          for (var e = t.size, r = 0, n = 0; n < e - 1; n++)
            for (var i = 0; i < e - 1; i++) {
              var o =
                t.get(n, i) +
                t.get(n, i + 1) +
                t.get(n + 1, i) +
                t.get(n + 1, i + 1)
              ;(4 !== o && 0 !== o) || r++
            }
          return r * a
        }),
        (s.getPenaltyN3 = function(t) {
          for (var e = t.size, r = 0, n = 0, i = 0, o = 0; o < e; o++) {
            n = i = 0
            for (var a = 0; a < e; a++)
              (n = ((n << 1) & 2047) | t.get(o, a)),
                a < 10 || (1488 !== n && 93 !== n) || r++,
                (i = ((i << 1) & 2047) | t.get(a, o)),
                a < 10 || (1488 !== i && 93 !== i) || r++
          }
          return r * h
        }),
        (s.getPenaltyN4 = function(t) {
          for (var e = 0, r = t.data.length, n = 0; n < r; n++) e += t.data[n]
          return Math.abs(Math.ceil((100 * e) / r / 5) - 10) * i
        }),
        (s.applyMask = function(t, e) {
          for (var r = e.size, n = 0; n < r; n++)
            for (var i = 0; i < r; i++)
              e.isReserved(i, n) || e.xor(i, n, o(t, i, n))
        }),
        (s.getBestMask = function(t, e) {
          for (
            var r = Object.keys(s.Patterns).length, n = 0, i = 1 / 0, o = 0;
            o < r;
            o++
          ) {
            e(o), s.applyMask(o, t)
            var a =
              s.getPenaltyN1(t) +
              s.getPenaltyN2(t) +
              s.getPenaltyN3(t) +
              s.getPenaltyN4(t)
            s.applyMask(o, t), a < i && ((i = a), (n = o))
          }
          return n
        })
    }),
    w = [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81,
    ],
    b = [
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430,
    ],
    P = {
      getBlocksCount: function(t, e) {
        switch (e) {
          case h.L:
            return w[4 * (t - 1) + 0]
          case h.M:
            return w[4 * (t - 1) + 1]
          case h.Q:
            return w[4 * (t - 1) + 2]
          case h.H:
            return w[4 * (t - 1) + 3]
          default:
            return
        }
      },
      getTotalCodewordsCount: function(t, e) {
        switch (e) {
          case h.L:
            return b[4 * (t - 1) + 0]
          case h.M:
            return b[4 * (t - 1) + 1]
          case h.Q:
            return b[4 * (t - 1) + 2]
          case h.H:
            return b[4 * (t - 1) + 3]
          default:
            return
        }
      },
    }
  ;(p = C.alloc
    ? ((d = C.alloc(512)), C.alloc(256))
    : ((d = new C(512)), new C(256))),
    (function() {
      for (var t = 1, e = 0; e < 255; e++)
        (p[(d[e] = t)] = e), 256 & (t <<= 1) && (t ^= 285)
      for (e = 255; e < 512; e++) d[e] = d[e - 255]
    })()
  var T = function(t) {
      return d[t]
    },
    A = function(t, e) {
      return 0 === t || 0 === e ? 0 : d[p[t] + p[e]]
    },
    L = t(function(t, n) {
      ;(n.mul = function(t, e) {
        var r = new C(t.length + e.length - 1)
        r.fill(0)
        for (var n = 0; n < t.length; n++)
          for (var i = 0; i < e.length; i++) r[n + i] ^= A(t[n], e[i])
        return r
      }),
        (n.mod = function(t, e) {
          for (var r = new C(t); 0 <= r.length - e.length; ) {
            for (var n = r[0], i = 0; i < e.length; i++) r[i] ^= A(e[i], n)
            for (var o = 0; o < r.length && 0 === r[o]; ) o++
            r = r.slice(o)
          }
          return r
        }),
        (n.generateECPolynomial = function(t) {
          for (var e = new C([1]), r = 0; r < t; r++) e = n.mul(e, [1, T(r)])
          return e
        })
    })
  function B(t) {
    ;(this.genPoly = void 0),
      (this.degree = t),
      this.degree && this.initialize(this.degree)
  }
  ;(B.prototype.initialize = function(t) {
    ;(this.degree = t), (this.genPoly = L.generateECPolynomial(this.degree))
  }),
    (B.prototype.encode = function(t) {
      if (!this.genPoly) throw Error('Encoder not initialized')
      var e = new C(this.degree)
      e.fill(0)
      var r = C.concat([t, e], t.length + this.degree),
        n = L.mod(r, this.genPoly),
        i = this.degree - n.length
      if (0 < i) {
        var o = new C(this.degree)
        return o.fill(0), n.copy(o, i), o
      }
      return n
    })
  var R = B,
    O = function(t) {
      return !isNaN(t) && 1 <= t && t <= 40
    },
    k =
      '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+',
    M =
      '(?:(?![A-Z0-9 $%*+\\-./:]|' +
      (k = k.replace(/u/g, '\\u')) +
      ')(?:.|[\r\n]))+',
    N = RegExp(k, 'g'),
    D = /[^A-Z0-9 $%*+\-.\/:]+/g,
    x = RegExp(M, 'g'),
    S = /[0-9]+/g,
    Y = /[A-Z $%*+\-.\/:]+/g,
    U = RegExp('^' + k + '$'),
    H = /^[0-9]+$/,
    F = /^[A-Z0-9 $%*+\-.\/:]+$/,
    z = {
      KANJI: N,
      BYTE_KANJI: D,
      BYTE: x,
      NUMERIC: S,
      ALPHANUMERIC: Y,
      testKanji: function(t) {
        return U.test(t)
      },
      testNumeric: function(t) {
        return H.test(t)
      },
      testAlphanumeric: function(t) {
        return F.test(t)
      },
    },
    G = t(function(t, r) {
      ;(r.NUMERIC = { id: 'Numeric', bit: 1, ccBits: [10, 12, 14] }),
        (r.ALPHANUMERIC = { id: 'Alphanumeric', bit: 2, ccBits: [9, 11, 13] }),
        (r.BYTE = { id: 'Byte', bit: 4, ccBits: [8, 16, 16] }),
        (r.KANJI = { id: 'Kanji', bit: 8, ccBits: [8, 10, 12] }),
        (r.MIXED = { bit: -1 }),
        (r.getCharCountIndicator = function(t, e) {
          if (!t.ccBits) throw Error('Invalid mode: ' + t)
          if (!O(e)) throw Error('Invalid version: ' + e)
          return 1 <= e && e < 10
            ? t.ccBits[0]
            : e < 27
            ? t.ccBits[1]
            : t.ccBits[2]
        }),
        (r.getBestModeForData = function(t) {
          return z.testNumeric(t)
            ? r.NUMERIC
            : z.testAlphanumeric(t)
            ? r.ALPHANUMERIC
            : z.testKanji(t)
            ? r.KANJI
            : r.BYTE
        }),
        (r.toString = function(t) {
          if (t && t.id) return t.id
          throw Error('Invalid mode')
        }),
        (r.isValid = function(t) {
          return t && t.bit && t.ccBits
        }),
        (r.from = function(t, e) {
          if (r.isValid(t)) return t
          try {
            return (function(t) {
              if ('string' != typeof t) throw Error('Param is not a string')
              switch (t.toLowerCase()) {
                case 'numeric':
                  return r.NUMERIC
                case 'alphanumeric':
                  return r.ALPHANUMERIC
                case 'kanji':
                  return r.KANJI
                case 'byte':
                  return r.BYTE
                default:
                  throw Error('Unknown mode: ' + t)
              }
            })(t)
          } catch (t) {
            return e
          }
        })
    }),
    W = {}.toString,
    q =
      Array.isArray ||
      function(t) {
        return '[object Array]' == W.call(t)
      },
    j = t(function(t, i) {
      var r = I.getBCHDigit(7973)
      function o(t, e) {
        return G.getCharCountIndicator(t, e) + 4
      }
      function a(t, r) {
        var n = 0
        return (
          t.forEach(function(t) {
            var e = o(t.mode, r)
            n += e + t.getBitsLength()
          }),
          n
        )
      }
      ;(i.from = function(t, e) {
        return O(t) ? parseInt(t, 10) : e
      }),
        (i.getCapacity = function(t, e, r) {
          if (!O(t)) throw Error('Invalid QR Code version')
          void 0 === r && (r = G.BYTE)
          var n =
            8 * (I.getSymbolTotalCodewords(t) - P.getTotalCodewordsCount(t, e))
          if (r === G.MIXED) return n
          var i = n - o(r, t)
          switch (r) {
            case G.NUMERIC:
              return Math.floor((i / 10) * 3)
            case G.ALPHANUMERIC:
              return Math.floor((i / 11) * 2)
            case G.KANJI:
              return Math.floor(i / 13)
            case G.BYTE:
            default:
              return Math.floor(i / 8)
          }
        }),
        (i.getBestVersionForData = function(t, e) {
          var r,
            n = h.from(e, h.M)
          if (q(t)) {
            if (1 < t.length)
              return (function(t, e) {
                for (var r = 1; r <= 40; r++) {
                  if (a(t, r) <= i.getCapacity(r, e, G.MIXED)) return r
                }
              })(t, n)
            if (0 === t.length) return 1
            r = t[0]
          } else r = t
          return (function(t, e, r) {
            for (var n = 1; n <= 40; n++)
              if (e <= i.getCapacity(n, r, t)) return n
          })(r.mode, r.getLength(), n)
        }),
        (i.getEncodedBits = function(t) {
          if (!O(t) || t < 7) throw Error('Invalid QR Code version')
          for (var e = t << 12; 0 <= I.getBCHDigit(e) - r; )
            e ^= 7973 << (I.getBCHDigit(e) - r)
          return (t << 12) | e
        })
    }),
    K = I.getBCHDigit(1335),
    J = {
      getEncodedBits: function(t, e) {
        for (var r = (t.bit << 3) | e, n = r << 10; 0 <= I.getBCHDigit(n) - K; )
          n ^= 1335 << (I.getBCHDigit(n) - K)
        return 21522 ^ ((r << 10) | n)
      },
    }
  function V(t) {
    ;(this.mode = G.NUMERIC), (this.data = '' + t)
  }
  ;(V.getBitsLength = function(t) {
    return 10 * Math.floor(t / 3) + (t % 3 ? (t % 3) * 3 + 1 : 0)
  }),
    (V.prototype.getLength = function() {
      return this.data.length
    }),
    (V.prototype.getBitsLength = function() {
      return V.getBitsLength(this.data.length)
    }),
    (V.prototype.write = function(t) {
      var e, r
      for (e = 0; e + 3 <= this.data.length; e += 3)
        (r = this.data.substr(e, 3)), t.put(parseInt(r, 10), 10)
      var n = this.data.length - e
      0 < n && ((r = this.data.substr(e)), t.put(parseInt(r, 10), 3 * n + 1))
    })
  var Q = V,
    $ = [
      '0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      'A',
      'B',
      'C',
      'D',
      'E',
      'F',
      'G',
      'H',
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
      ' ',
      '$',
      '%',
      '*',
      '+',
      '-',
      '.',
      '/',
      ':',
    ]
  function Z(t) {
    ;(this.mode = G.ALPHANUMERIC), (this.data = t)
  }
  ;(Z.getBitsLength = function(t) {
    return 11 * Math.floor(t / 2) + (t % 2) * 6
  }),
    (Z.prototype.getLength = function() {
      return this.data.length
    }),
    (Z.prototype.getBitsLength = function() {
      return Z.getBitsLength(this.data.length)
    }),
    (Z.prototype.write = function(t) {
      var e
      for (e = 0; e + 2 <= this.data.length; e += 2) {
        var r = 45 * $.indexOf(this.data[e])
        ;(r += $.indexOf(this.data[e + 1])), t.put(r, 11)
      }
      this.data.length % 2 && t.put($.indexOf(this.data[e]), 6)
    })
  var X = Z
  function tt(t) {
    ;(this.mode = G.BYTE), (this.data = new C(t))
  }
  ;(tt.getBitsLength = function(t) {
    return 8 * t
  }),
    (tt.prototype.getLength = function() {
      return this.data.length
    }),
    (tt.prototype.getBitsLength = function() {
      return tt.getBitsLength(this.data.length)
    }),
    (tt.prototype.write = function(t) {
      for (var e = 0, r = this.data.length; e < r; e++) t.put(this.data[e], 8)
    })
  var et = tt
  function rt(t) {
    ;(this.mode = G.KANJI), (this.data = t)
  }
  ;(rt.getBitsLength = function(t) {
    return 13 * t
  }),
    (rt.prototype.getLength = function() {
      return this.data.length
    }),
    (rt.prototype.getBitsLength = function() {
      return rt.getBitsLength(this.data.length)
    }),
    (rt.prototype.write = function(t) {
      var e
      for (e = 0; e < this.data.length; e++) {
        var r = I.toSJIS(this.data[e])
        if (33088 > r || r > 40956) {
          if (r < 57408 || 60351 < r)
            throw Error(
              'Invalid SJIS character: ' +
                this.data[e] +
                '\nMake sure your charset is UTF-8'
            )
          r -= 49472
        } else r -= 33088
        t.put((r = 192 * ((r >>> 8) & 255) + (255 & r)), 13)
      }
    })
  var nt = rt,
    it = t(function(t) {
      var d = {
        single_source_shortest_paths: function(t, e, r) {
          var n = {},
            i = {}
          i[e] = 0
          var o,
            a,
            s,
            h,
            u,
            f,
            l,
            c = d.PriorityQueue.make()
          for (c.push(e, 0); !c.empty(); )
            for (s in ((h = (o = c.pop()).cost), (u = t[(a = o.value)] || {})))
              u.hasOwnProperty(s) &&
                ((f = h + u[s]),
                (void 0 === (l = i[s]) || f < l) &&
                  (c.push(s, (i[s] = f)), (n[s] = a)))
          if (void 0 === r || void 0 !== i[r]) return n
          throw Error('Could not find a path from ' + e + ' to ' + r + '.')
        },
        extract_shortest_path_from_predecessor_list: function(t, e) {
          for (var r = [], n = e; n; ) r.push(n), (n = t[n])
          return r.reverse(), r
        },
        find_path: function(t, e, r) {
          var n = d.single_source_shortest_paths(t, e, r)
          return d.extract_shortest_path_from_predecessor_list(n, r)
        },
        PriorityQueue: {
          make: function(t) {
            var e,
              r = d.PriorityQueue,
              n = {}
            for (e in ((t = t || {}), r)) r.hasOwnProperty(e) && (n[e] = r[e])
            return (n.queue = []), (n.sorter = t.sorter || r.default_sorter), n
          },
          default_sorter: function(t, e) {
            return t.cost - e.cost
          },
          push: function(t, e) {
            this.queue.push({ value: t, cost: e }), this.queue.sort(this.sorter)
          },
          pop: function() {
            return this.queue.shift()
          },
          empty: function() {
            return 0 === this.queue.length
          },
        },
      }
      t.exports = d
    }),
    ot = t(function(t, a) {
      function s(t) {
        return unescape(encodeURIComponent(t)).length
      }
      function o(t, e, r) {
        for (var n, i = []; null !== (n = t.exec(r)); )
          i.push({ data: n[0], index: n.index, mode: e, length: n[0].length })
        return i
      }
      function h(t) {
        var e,
          r,
          n = o(z.NUMERIC, G.NUMERIC, t),
          i = o(z.ALPHANUMERIC, G.ALPHANUMERIC, t)
        return (
          (r = I.isKanjiModeEnabled()
            ? ((e = o(z.BYTE, G.BYTE, t)), o(z.KANJI, G.KANJI, t))
            : ((e = o(z.BYTE_KANJI, G.BYTE, t)), [])),
          n
            .concat(i, e, r)
            .sort(function(t, e) {
              return t.index - e.index
            })
            .map(function(t) {
              return { data: t.data, mode: t.mode, length: t.length }
            })
        )
      }
      function d(t, e) {
        switch (e) {
          case G.NUMERIC:
            return Q.getBitsLength(t)
          case G.ALPHANUMERIC:
            return X.getBitsLength(t)
          case G.KANJI:
            return nt.getBitsLength(t)
          case G.BYTE:
            return et.getBitsLength(t)
        }
      }
      function r(t, e) {
        var r,
          n = G.getBestModeForData(t)
        if ((r = G.from(e, n)) !== G.BYTE && r.bit < n.bit)
          throw Error(
            '"' +
              t +
              '" cannot be encoded with mode ' +
              G.toString(r) +
              '.\n Suggested mode is: ' +
              G.toString(n)
          )
        switch ((r !== G.KANJI || I.isKanjiModeEnabled() || (r = G.BYTE), r)) {
          case G.NUMERIC:
            return new Q(t)
          case G.ALPHANUMERIC:
            return new X(t)
          case G.KANJI:
            return new nt(t)
          case G.BYTE:
            return new et(t)
        }
      }
      ;(a.fromArray = function(t) {
        return t.reduce(function(t, e) {
          return (
            'string' == typeof e
              ? t.push(r(e, null))
              : e.data && t.push(r(e.data, e.mode)),
            t
          )
        }, [])
      }),
        (a.fromString = function(t, e) {
          for (
            var r = (function(t, e) {
                for (
                  var r = {}, n = { start: {} }, i = ['start'], o = 0;
                  o < t.length;
                  o++
                ) {
                  for (var a = t[o], s = [], h = 0; h < a.length; h++) {
                    var u = a[h],
                      f = '' + o + h
                    s.push(f), (r[f] = { node: u, lastCount: 0 }), (n[f] = {})
                    for (var l = 0; l < i.length; l++) {
                      var c = i[l]
                      r[c] && r[c].node.mode === u.mode
                        ? ((n[c][f] =
                            d(r[c].lastCount + u.length, u.mode) -
                            d(r[c].lastCount, u.mode)),
                          (r[c].lastCount += u.length))
                        : (r[c] && (r[c].lastCount = u.length),
                          (n[c][f] =
                            d(u.length, u.mode) +
                            4 +
                            G.getCharCountIndicator(u.mode, e)))
                    }
                  }
                  i = s
                }
                for (l = 0; l < i.length; l++) n[i[l]].end = 0
                return { map: n, table: r }
              })(
                (function(t) {
                  for (var e = [], r = 0; r < t.length; r++) {
                    var n = t[r]
                    switch (n.mode) {
                      case G.NUMERIC:
                        e.push([
                          n,
                          {
                            data: n.data,
                            mode: G.ALPHANUMERIC,
                            length: n.length,
                          },
                          { data: n.data, mode: G.BYTE, length: n.length },
                        ])
                        break
                      case G.ALPHANUMERIC:
                        e.push([
                          n,
                          { data: n.data, mode: G.BYTE, length: n.length },
                        ])
                        break
                      case G.KANJI:
                        e.push([
                          n,
                          { data: n.data, mode: G.BYTE, length: s(n.data) },
                        ])
                        break
                      case G.BYTE:
                        e.push([
                          { data: n.data, mode: G.BYTE, length: s(n.data) },
                        ])
                    }
                  }
                  return e
                })(h(t)),
                e
              ),
              n = it.find_path(r.map, 'start', 'end'),
              i = [],
              o = 1;
            o < n.length - 1;
            o++
          )
            i.push(r.table[n[o]].node)
          return a.fromArray(
            (function(t) {
              return t.reduce(function(t, e) {
                var r = t.length - 1 < 0 ? null : t[t.length - 1]
                return (
                  r && r.mode === e.mode
                    ? (t[t.length - 1].data += e.data)
                    : t.push(e),
                  t
                )
              }, [])
            })(i)
          )
        }),
        (a.rawSplit = function(t) {
          return a.fromArray(h(t))
        })
    })
  function at(t, e, r) {
    var n,
      i,
      o = t.size,
      a = J.getEncodedBits(e, r)
    for (n = 0; n < 15; n++)
      t.set(
        n < 6 ? n : n < 8 ? n + 1 : o - 15 + n,
        8,
        (i = 1 == ((a >> n) & 1)),
        !0
      ),
        t.set(8, n < 8 ? o - n - 1 : n < 9 ? 15 - n - 1 + 1 : 15 - n - 1, i, !0)
    t.set(o - 8, 8, 1, !0)
  }
  function st(e, t, r) {
    var n = new l()
    r.forEach(function(t) {
      n.put(t.mode.bit, 4),
        n.put(t.getLength(), G.getCharCountIndicator(t.mode, e)),
        t.write(n)
    })
    var i = 8 * (I.getSymbolTotalCodewords(e) - P.getTotalCodewordsCount(e, t))
    for (
      n.getLengthInBits() + 4 > i || n.put(0, 4);
      n.getLengthInBits() % 8 != 0;

    )
      n.putBit(0)
    for (var o = (i - n.getLengthInBits()) / 8, a = 0; a < o; a++)
      n.put(a % 2 ? 17 : 236, 8)
    return (function(t, e, r) {
      for (
        var n = I.getSymbolTotalCodewords(e),
          i = P.getTotalCodewordsCount(e, r),
          o = n - i,
          a = P.getBlocksCount(e, r),
          s = a - (n % a),
          h = Math.floor(n / a),
          u = Math.floor(o / a),
          f = 1 + u,
          l = h - u,
          c = new R(l),
          d = 0,
          p = Array(a),
          g = Array(a),
          _ = 0,
          v = new C(t.buffer),
          m = 0;
        m < a;
        m++
      ) {
        var y = m < s ? u : f
        ;(p[m] = v.slice(d, d + y)),
          (g[m] = c.encode(p[m])),
          (d += y),
          (_ = Math.max(_, y))
      }
      var E,
        w,
        b = new C(n),
        T = 0
      for (E = 0; E < _; E++)
        for (w = 0; w < a; w++) E < p[w].length && (b[T++] = p[w][E])
      for (E = 0; E < l; E++) for (w = 0; w < a; w++) b[T++] = g[w][E]
      return b
    })(n, e, t)
  }
  function ht(t, e, r, n) {
    var i
    if (q(t)) i = ot.fromArray(t)
    else {
      if ('string' != typeof t) throw Error('Invalid data')
      var o = e
      if (!o) {
        var a = ot.rawSplit(t)
        o = j.getBestVersionForData(a, r)
      }
      i = ot.fromString(t, o || 40)
    }
    var s = j.getBestVersionForData(i, r)
    if (!s)
      throw Error('The amount of data is too big to be stored in a QR Code')
    if (e) {
      if (e < s)
        throw Error(
          '\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: ' +
            s +
            '.\n'
        )
    } else e = s
    var h = st(e, r, i),
      u = I.getSymbolSize(e),
      f = new g(u)
    return (
      (function(t, e) {
        for (var r = t.size, n = y.getPositions(e), i = 0; i < n.length; i++)
          for (var o = n[i][0], a = n[i][1], s = -1; s <= 7; s++)
            if (-1 < o + s && o + s < r)
              for (var h = -1; h <= 7; h++)
                -1 < a + h &&
                  a + h < r &&
                  t.set(
                    o + s,
                    a + h,
                    !(
                      (s < 0 || 6 < s || (0 !== h && 6 !== h)) &&
                      (h < 0 || 6 < h || (0 !== s && 6 !== s)) &&
                      (s < 2 || 4 < s || h < 2 || 4 < h)
                    ),
                    !0
                  )
      })(f, e),
      (function(t) {
        for (var e = t.size, r = 8; r < e - 8; r++) {
          var n = r % 2 == 0
          t.set(r, 6, n, !0), t.set(6, r, n, !0)
        }
      })(f),
      (function(t, e) {
        for (var r = _.getPositions(e), n = 0; n < r.length; n++)
          for (var i = r[n][0], o = r[n][1], a = -2; a <= 2; a++)
            for (var s = -2; s <= 2; s++)
              t.set(
                i + a,
                o + s,
                -2 === a ||
                  2 === a ||
                  -2 === s ||
                  2 === s ||
                  (0 === a && 0 === s),
                !0
              )
      })(f, e),
      at(f, r, 0),
      e < 7 ||
        (function(t, e) {
          for (
            var r, n, i, o = t.size, a = j.getEncodedBits(e), s = 0;
            s < 18;
            s++
          )
            t.set(
              (r = Math.floor(s / 3)),
              (n = (s % 3) + o - 8 - 3),
              (i = 1 == ((a >> s) & 1)),
              !0
            ),
              t.set(n, r, i, !0)
        })(f, e),
      (function(t, e) {
        for (
          var r = t.size, n = -1, i = r - 1, o = 7, a = 0, s = r - 1;
          0 < s;
          s -= 2
        )
          for (6 === s && s--; ; ) {
            for (var h = 0; h < 2; h++)
              if (!t.isReserved(i, s - h)) {
                var u = !1
                a < e.length && (u = 1 == ((e[a] >>> o) & 1)),
                  t.set(i, s - h, u),
                  -1 === --o && (a++, (o = 7))
              }
            if ((i += n) < 0 || r <= i) {
              ;(i -= n), (n = -n)
              break
            }
          }
      })(f, h),
      isNaN(n) && (n = E.getBestMask(f, at.bind(null, f, r))),
      E.applyMask(n, f),
      at(f, r, n),
      {
        modules: f,
        version: e,
        errorCorrectionLevel: r,
        maskPattern: n,
        segments: i,
      }
    )
  }
  function ut(t, e, r) {
    var n = t + e - r,
      i = Math.abs(n - t),
      o = Math.abs(n - e),
      a = Math.abs(n - r)
    return o < i || a < i ? (a < o ? r : e) : t
  }
  var ft = function(t, e) {
      if (void 0 === t || '' === t) throw Error('No input text')
      var r,
        n,
        i = h.M
      return (
        void 0 !== e &&
          ((i = h.from(e.errorCorrectionLevel, h.M)),
          (r = j.from(e.version)),
          (n = E.from(e.maskPattern)),
          e.toSJISFunc && I.setToSJISFunction(e.toSJISFunc)),
        ht(t, r, i, n)
      )
    },
    lt = t(function(t) {
      var e = (t.exports = function() {
        r.call(this),
          (this._buffers = []),
          (this._buffered = 0),
          (this._reads = []),
          (this._paused = !1),
          (this._encoding = 'utf8'),
          (this.writable = !0)
      })
      o.inherits(e, r),
        (e.prototype.read = function(t, e) {
          this._reads.push({ length: Math.abs(t), allowLess: t < 0, func: e }),
            process.nextTick(
              function() {
                this._process(),
                  this._paused &&
                    0 < this._reads.length &&
                    ((this._paused = !1), this.emit('drain'))
              }.bind(this)
            )
        }),
        (e.prototype.write = function(t, e) {
          return this.writable
            ? ((r = Buffer.isBuffer(t)
                ? t
                : new Buffer(t, e || this._encoding)),
              this._buffers.push(r),
              (this._buffered += r.length),
              this._process(),
              this._reads && 0 === this._reads.length && (this._paused = !0),
              this.writable && !this._paused)
            : (this.emit('error', Error('Stream not writable')), !1)
          var r
        }),
        (e.prototype.end = function(t, e) {
          t && this.write(t, e),
            (this.writable = !1),
            this._buffers &&
              (0 === this._buffers.length
                ? this._end()
                : (this._buffers.push(null), this._process()))
        }),
        (e.prototype.destroySoon = e.prototype.end),
        (e.prototype._end = function() {
          0 < this._reads.length &&
            this.emit('error', Error('Unexpected end of input')),
            this.destroy()
        }),
        (e.prototype.destroy = function() {
          this._buffers &&
            ((this.writable = !1),
            (this._reads = null),
            (this._buffers = null),
            this.emit('close'))
        }),
        (e.prototype._processReadAllowingLess = function(t) {
          this._reads.shift()
          var e = this._buffers[0]
          t.length < e.length
            ? ((this._buffered -= t.length),
              (this._buffers[0] = e.slice(t.length)),
              t.func.call(this, e.slice(0, t.length)))
            : ((this._buffered -= e.length),
              this._buffers.shift(),
              t.func.call(this, e))
        }),
        (e.prototype._processRead = function(t) {
          this._reads.shift()
          for (var e = 0, r = 0, n = new Buffer(t.length); e < t.length; ) {
            var i = this._buffers[r++],
              o = Math.min(i.length, t.length - e)
            i.copy(n, e, 0, o),
              (e += o),
              o !== i.length && (this._buffers[--r] = i.slice(o))
          }
          0 < r && this._buffers.splice(0, r),
            (this._buffered -= t.length),
            t.func.call(this, n)
        }),
        (e.prototype._process = function() {
          try {
            for (
              ;
              0 < this._buffered && this._reads && 0 < this._reads.length;

            ) {
              var t = this._reads[0]
              if (t.allowLess) this._processReadAllowingLess(t)
              else {
                if (this._buffered < t.length) break
                this._processRead(t)
              }
            }
            this._buffers && !this.writable && this._end()
          } catch (t) {
            this.emit('error', t)
          }
        })
    }),
    ct = [
      { x: [0], y: [0] },
      { x: [4], y: [0] },
      { x: [0, 4], y: [4] },
      { x: [2, 6], y: [0, 4] },
      { x: [0, 2, 4, 6], y: [2, 6] },
      { x: [1, 3, 5, 7], y: [0, 2, 4, 6] },
      { x: [0, 1, 2, 3, 4, 5, 6, 7], y: [1, 3, 5, 7] },
    ],
    dt = function(t, e) {
      for (
        var r = [],
          n = t % 8,
          i = e % 8,
          o = (t - n) / 8,
          a = (e - i) / 8,
          s = 0;
        s < ct.length;
        s++
      ) {
        for (
          var h = ct[s], u = o * h.x.length, f = a * h.y.length, l = 0;
          l < h.x.length && n > h.x[l];
          l++
        )
          u++
        for (l = 0; l < h.y.length && i > h.y[l]; l++) f++
        0 < u && 0 < f && r.push({ width: u, height: f, index: s })
      }
      return r
    },
    pt = function(o) {
      return function(t, e, r) {
        var n = t % ct[r].x.length,
          i = e % ct[r].y.length
        return (
          4 * (((t - n) / ct[r].x.length) * 8 + ct[r].x[n]) +
          (((e - i) / ct[r].y.length) * 8 + ct[r].y[i]) * o * 4
        )
      }
    },
    gt = t(function(t) {
      function u(t, e, r) {
        var n = t * e
        return 8 !== r && (n = Math.ceil(n / (8 / r))), n
      }
      var e = (t.exports = function(t, e) {
        var r = t.width,
          n = t.height,
          i = t.interlace,
          o = t.bpp,
          a = t.depth
        if (
          ((this.read = e.read),
          (this.write = e.write),
          (this.complete = e.complete),
          (this._imageIndex = 0),
          (this._images = []),
          i)
        )
          for (var s = dt(r, n), h = 0; h < s.length; h++)
            this._images.push({
              byteWidth: u(s[h].width, o, a),
              height: s[h].height,
              lineIndex: 0,
            })
        else
          this._images.push({ byteWidth: u(r, o, a), height: n, lineIndex: 0 })
        this._xComparison = 8 === a ? o : 16 === a ? 2 * o : 1
      })
      ;(e.prototype.start = function() {
        this.read(
          this._images[this._imageIndex].byteWidth + 1,
          this._reverseFilterLine.bind(this)
        )
      }),
        (e.prototype._unFilterType1 = function(t, e, r) {
          for (var n = this._xComparison, i = n - 1, o = 0; o < r; o++) {
            e[o] = t[1 + o] + (i < o ? e[o - n] : 0)
          }
        }),
        (e.prototype._unFilterType2 = function(t, e, r) {
          for (var n = this._lastLine, i = 0; i < r; i++) {
            e[i] = t[1 + i] + (n ? n[i] : 0)
          }
        }),
        (e.prototype._unFilterType3 = function(t, e, r) {
          for (
            var n = this._xComparison, i = n - 1, o = this._lastLine, a = 0;
            a < r;
            a++
          ) {
            e[a] =
              t[1 + a] +
              Math.floor(((i < a ? e[a - n] : 0) + (o ? o[a] : 0)) / 2)
          }
        }),
        (e.prototype._unFilterType4 = function(t, e, r) {
          for (
            var n = this._xComparison, i = n - 1, o = this._lastLine, a = 0;
            a < r;
            a++
          ) {
            var s = t[1 + a],
              h = ut(
                i < a ? e[a - n] : 0,
                o ? o[a] : 0,
                i < a && o ? o[a - n] : 0
              )
            e[a] = s + h
          }
        }),
        (e.prototype._reverseFilterLine = function(t) {
          var e,
            r = t[0],
            n = this._images[this._imageIndex],
            i = n.byteWidth
          if (0 === r) e = t.slice(1, i + 1)
          else
            switch (((e = new Buffer(i)), r)) {
              case 1:
                this._unFilterType1(t, e, i)
                break
              case 2:
                this._unFilterType2(t, e, i)
                break
              case 3:
                this._unFilterType3(t, e, i)
                break
              case 4:
                this._unFilterType4(t, e, i)
                break
              default:
                throw Error('Unrecognised filter type - ' + r)
            }
          this.write(e),
            n.lineIndex++,
            n.lineIndex < n.height
              ? (this._lastLine = e)
              : ((this._lastLine = null),
                this._imageIndex++,
                (n = this._images[this._imageIndex])),
            n
              ? this.read(n.byteWidth + 1, this._reverseFilterLine.bind(this))
              : ((this._lastLine = null), this.complete())
        })
    }),
    _t = t(function(t) {
      var e = (t.exports = function(t) {
        lt.call(this)
        var e = [],
          r = this
        ;(this._filter = new gt(t, {
          read: this.read.bind(this),
          write: function(t) {
            e.push(t)
          },
          complete: function() {
            r.emit('complete', Buffer.concat(e))
          },
        })),
          this._filter.start()
      })
      o.inherits(e, lt)
    }),
    vt = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: { 0: 1, 2: 3, 3: 1, 4: 2, 6: 4 },
      GAMMA_DIVISION: 1e5,
    },
    mt = t(function(t) {
      var n = []
      !(function() {
        for (var t = 0; t < 256; t++) {
          for (var e = t, r = 0; r < 8; r++)
            1 & e ? (e = 3988292384 ^ (e >>> 1)) : (e >>>= 1)
          n[t] = e
        }
      })()
      var e = (t.exports = function() {
        this._crc = -1
      })
      ;(e.prototype.write = function(t) {
        for (var e = 0; e < t.length; e++)
          this._crc = n[255 & (this._crc ^ t[e])] ^ (this._crc >>> 8)
        return !0
      }),
        (e.prototype.crc32 = function() {
          return -1 ^ this._crc
        }),
        (e.crc32 = function(t) {
          for (var e = -1, r = 0; r < t.length; r++)
            e = n[255 & (e ^ t[r])] ^ (e >>> 8)
          return -1 ^ e
        })
    }),
    yt = t(function(t) {
      var e = (t.exports = function(t, e) {
        ;((this._options = t).checkCRC = !1 !== t.checkCRC),
          (this._hasIHDR = !1),
          (this._hasIEND = !1),
          (this._emittedHeadersFinished = !1),
          (this._palette = []),
          (this._colorType = 0),
          (this._chunks = {}),
          (this._chunks[vt.TYPE_IHDR] = this._handleIHDR.bind(this)),
          (this._chunks[vt.TYPE_IEND] = this._handleIEND.bind(this)),
          (this._chunks[vt.TYPE_IDAT] = this._handleIDAT.bind(this)),
          (this._chunks[vt.TYPE_PLTE] = this._handlePLTE.bind(this)),
          (this._chunks[vt.TYPE_tRNS] = this._handleTRNS.bind(this)),
          (this._chunks[vt.TYPE_gAMA] = this._handleGAMA.bind(this)),
          (this.read = e.read),
          (this.error = e.error),
          (this.metadata = e.metadata),
          (this.gamma = e.gamma),
          (this.transColor = e.transColor),
          (this.palette = e.palette),
          (this.parsed = e.parsed),
          (this.inflateData = e.inflateData),
          (this.finished = e.finished),
          (this.simpleTransparency = e.simpleTransparency),
          (this.headersFinished = e.headersFinished || function() {})
      })
      ;(e.prototype.start = function() {
        this.read(vt.PNG_SIGNATURE.length, this._parseSignature.bind(this))
      }),
        (e.prototype._parseSignature = function(t) {
          for (var e = vt.PNG_SIGNATURE, r = 0; r < e.length; r++)
            if (t[r] !== e[r])
              return void this.error(Error('Invalid file signature'))
          this.read(8, this._parseChunkBegin.bind(this))
        }),
        (e.prototype._parseChunkBegin = function(t) {
          for (
            var e = t.readUInt32BE(0), r = t.readUInt32BE(4), n = '', i = 4;
            i < 8;
            i++
          )
            n += String.fromCharCode(t[i])
          var o = !!(32 & t[4])
          if (this._hasIHDR || r === vt.TYPE_IHDR) {
            if (
              ((this._crc = new mt()),
              this._crc.write(new Buffer(n)),
              this._chunks[r])
            )
              return this._chunks[r](e)
            o
              ? this.read(e + 4, this._skipChunk.bind(this))
              : this.error(Error('Unsupported critical chunk type ' + n))
          } else this.error(Error('Expected IHDR on beggining'))
        }),
        (e.prototype._skipChunk = function() {
          this.read(8, this._parseChunkBegin.bind(this))
        }),
        (e.prototype._handleChunkEnd = function() {
          this.read(4, this._parseChunkEnd.bind(this))
        }),
        (e.prototype._parseChunkEnd = function(t) {
          var e = t.readInt32BE(0),
            r = this._crc.crc32()
          this._options.checkCRC && r !== e
            ? this.error(Error('Crc error - ' + e + ' - ' + r))
            : this._hasIEND || this.read(8, this._parseChunkBegin.bind(this))
        }),
        (e.prototype._handleIHDR = function(t) {
          this.read(t, this._parseIHDR.bind(this))
        }),
        (e.prototype._parseIHDR = function(t) {
          this._crc.write(t)
          var e = t.readUInt32BE(0),
            r = t.readUInt32BE(4),
            n = t[8],
            i = t[9],
            o = t[12]
          if (8 === n || 4 === n || 2 === n || 1 === n || 16 === n)
            if (i in vt.COLORTYPE_TO_BPP_MAP)
              if (0 === t[10])
                if (0 === t[11])
                  if (0 === o || 1 === o) {
                    this._colorType = i
                    var a = vt.COLORTYPE_TO_BPP_MAP[this._colorType]
                    ;(this._hasIHDR = !0),
                      this.metadata({
                        width: e,
                        height: r,
                        depth: n,
                        interlace: !!o,
                        palette: !!(i & vt.COLORTYPE_PALETTE),
                        color: !!(i & vt.COLORTYPE_COLOR),
                        alpha: !!(i & vt.COLORTYPE_ALPHA),
                        bpp: a,
                        colorType: i,
                      }),
                      this._handleChunkEnd()
                  } else this.error(Error('Unsupported interlace method'))
                else this.error(Error('Unsupported filter method'))
              else this.error(Error('Unsupported compression method'))
            else this.error(Error('Unsupported color type'))
          else this.error(Error('Unsupported bit depth ' + n))
        }),
        (e.prototype._handlePLTE = function(t) {
          this.read(t, this._parsePLTE.bind(this))
        }),
        (e.prototype._parsePLTE = function(t) {
          this._crc.write(t)
          for (var e = Math.floor(t.length / 3), r = 0; r < e; r++)
            this._palette.push([t[3 * r], t[3 * r + 1], t[3 * r + 2], 255])
          this.palette(this._palette), this._handleChunkEnd()
        }),
        (e.prototype._handleTRNS = function(t) {
          this.simpleTransparency(), this.read(t, this._parseTRNS.bind(this))
        }),
        (e.prototype._parseTRNS = function(t) {
          if (
            (this._crc.write(t), this._colorType === vt.COLORTYPE_PALETTE_COLOR)
          ) {
            if (0 === this._palette.length)
              return void this.error(
                Error('Transparency chunk must be after palette')
              )
            if (this._palette.length < t.length)
              return void this.error(
                Error('More transparent colors than palette size')
              )
            for (var e = 0; e < t.length; e++) this._palette[e][3] = t[e]
            this.palette(this._palette)
          }
          this._colorType === vt.COLORTYPE_GRAYSCALE &&
            this.transColor([t.readUInt16BE(0)]),
            this._colorType === vt.COLORTYPE_COLOR &&
              this.transColor([
                t.readUInt16BE(0),
                t.readUInt16BE(2),
                t.readUInt16BE(4),
              ]),
            this._handleChunkEnd()
        }),
        (e.prototype._handleGAMA = function(t) {
          this.read(t, this._parseGAMA.bind(this))
        }),
        (e.prototype._parseGAMA = function(t) {
          this._crc.write(t),
            this.gamma(t.readUInt32BE(0) / vt.GAMMA_DIVISION),
            this._handleChunkEnd()
        }),
        (e.prototype._handleIDAT = function(t) {
          this._emittedHeadersFinished ||
            ((this._emittedHeadersFinished = !0), this.headersFinished()),
            this.read(-t, this._parseIDAT.bind(this, t))
        }),
        (e.prototype._parseIDAT = function(t, e) {
          if (
            (this._crc.write(e),
            this._colorType === vt.COLORTYPE_PALETTE_COLOR &&
              0 === this._palette.length)
          )
            throw Error('Expected palette not found')
          this.inflateData(e)
          var r = t - e.length
          0 < r ? this._handleIDAT(r) : this._handleChunkEnd()
        }),
        (e.prototype._handleIEND = function(t) {
          this.read(t, this._parseIEND.bind(this))
        }),
        (e.prototype._parseIEND = function(t) {
          this._crc.write(t),
            (this._hasIEND = !0),
            this._handleChunkEnd(),
            this.finished && this.finished()
        })
    }),
    Et = [
      function() {},
      function(t, e, r, n) {
        if (n === e.length) throw Error('Ran out of data')
        var i = e[n]
        ;(t[r] = i), (t[r + 1] = i), (t[r + 2] = i), (t[r + 3] = 255)
      },
      function(t, e, r, n) {
        if (e.length <= n + 1) throw Error('Ran out of data')
        var i = e[n]
        ;(t[r] = i), (t[r + 1] = i), (t[r + 2] = i), (t[r + 3] = e[n + 1])
      },
      function(t, e, r, n) {
        if (e.length <= n + 2) throw Error('Ran out of data')
        ;(t[r] = e[n]),
          (t[r + 1] = e[n + 1]),
          (t[r + 2] = e[n + 2]),
          (t[r + 3] = 255)
      },
      function(t, e, r, n) {
        if (e.length <= n + 3) throw Error('Ran out of data')
        ;(t[r] = e[n]),
          (t[r + 1] = e[n + 1]),
          (t[r + 2] = e[n + 2]),
          (t[r + 3] = e[n + 3])
      },
    ],
    wt = [
      function() {},
      function(t, e, r, n) {
        var i = e[0]
        ;(t[r] = i), (t[r + 1] = i), (t[r + 2] = i), (t[r + 3] = n)
      },
      function(t, e, r) {
        var n = e[0]
        ;(t[r] = n), (t[r + 1] = n), (t[r + 2] = n), (t[r + 3] = e[1])
      },
      function(t, e, r, n) {
        ;(t[r] = e[0]), (t[r + 1] = e[1]), (t[r + 2] = e[2]), (t[r + 3] = n)
      },
      function(t, e, r) {
        ;(t[r] = e[0]), (t[r + 1] = e[1]), (t[r + 2] = e[2]), (t[r + 3] = e[3])
      },
    ]
  function bt(t, e, r, n, i, o) {
    for (var a = t.width, s = t.height, h = t.index, u = 0; u < s; u++)
      for (var f = 0; f < a; f++) {
        var l = r(f, u, h)
        Et[n](e, i, l, o), (o += n)
      }
    return o
  }
  function Tt(t, e, r, n, i, o) {
    for (var a = t.width, s = t.height, h = t.index, u = 0; u < s; u++) {
      for (var f = 0; f < a; f++) {
        var l = i.get(n),
          c = r(f, u, h)
        wt[n](e, l, c, o)
      }
      i.resetAfterLine()
    }
  }
  var Ct = function(t, e) {
    var r,
      n = e.width,
      i = e.height,
      o = e.depth,
      a = e.bpp,
      s = e.interlace
    if (8 !== o)
      var h = (function(r, n) {
        var i = [],
          o = 0
        function a() {
          if (o === r.length) throw Error('Ran out of data')
          var t,
            e = r[o]
          switch ((o++, n)) {
            default:
              throw Error('unrecognised depth')
            case 16:
              ;(t = r[o]), o++, i.push((e << 8) + t)
              break
            case 4:
              i.push(e >> 4, (t = 15 & e))
              break
            case 2:
              i.push((e >> 6) & 3, (t = (e >> 4) & 3), (e >> 2) & 3, 3 & e)
              break
            case 1:
              i.push(
                (e >> 7) & 1,
                (t = (e >> 6) & 1),
                (e >> 5) & 1,
                (e >> 4) & 1,
                (e >> 3) & 1,
                (e >> 2) & 1,
                (e >> 1) & 1,
                1 & e
              )
          }
        }
        return {
          get: function(t) {
            for (; i.length < t; ) a()
            var e = i.slice(0, t)
            return (i = i.slice(t)), e
          },
          resetAfterLine: function() {
            i.length = 0
          },
          end: function() {
            if (o !== r.length) throw Error('extra data found')
          },
        }
      })(t, o)
    r = 8 < o ? new Uint16Array(n * i * 4) : new Buffer(n * i * 4)
    var u,
      f,
      l = Math.pow(2, o) - 1,
      c = 0
    if (s) (u = dt(n, i)), (f = pt(n, i))
    else {
      var d = 0
      ;(f = function() {
        var t = d
        return (d += 4), t
      }),
        (u = [{ width: n, height: i }])
    }
    for (var p = 0; p < u.length; p++)
      8 === o ? (c = bt(u[p], r, f, a, t, c)) : Tt(u[p], r, f, a, h, l)
    if (8 === o) {
      if (c !== t.length) throw Error('extra data found')
    } else h.end()
    return r
  }
  function It(t, e) {
    var r = e.depth,
      n = e.width,
      i = e.height,
      o = e.transColor,
      a = t
    return (
      3 === e.colorType
        ? (function(t, e, r, n, i) {
            for (var o = 0, a = 0; a < n; a++)
              for (var s = 0; s < r; s++) {
                var h = i[t[o]]
                if (!h) throw Error('index ' + t[o] + ' not in palette')
                for (var u = 0; u < 4; u++) e[o + u] = h[u]
                o += 4
              }
          })(t, a, n, i, e.palette)
        : (o &&
            (function(t, e, r, n, i) {
              for (var o = 0, a = 0; a < n; a++)
                for (var s = 0; s < r; s++) {
                  var h = !1
                  if (
                    (1 === i.length
                      ? i[0] === t[o] && (h = !0)
                      : i[0] === t[o] &&
                        i[1] === t[o + 1] &&
                        i[2] === t[o + 2] &&
                        (h = !0),
                    h)
                  )
                    for (var u = 0; u < 4; u++) e[o + u] = 0
                  o += 4
                }
            })(t, a, n, i, o),
          8 !== r &&
            (16 === r && (a = new Buffer(n * i * 4)),
            (function(t, e, r, n, i) {
              for (var o = Math.pow(2, i) - 1, a = 0, s = 0; s < n; s++)
                for (var h = 0; h < r; h++) {
                  for (var u = 0; u < 4; u++)
                    e[a + u] = Math.floor((255 * t[a + u]) / o + 0.5)
                  a += 4
                }
            })(t, a, n, i, r))),
      a
    )
  }
  var Pt = t(function(t) {
    var e = (t.exports = function(t) {
      lt.call(this),
        (this._parser = new yt(t, {
          read: this.read.bind(this),
          error: this._handleError.bind(this),
          metadata: this._handleMetaData.bind(this),
          gamma: this.emit.bind(this, 'gamma'),
          palette: this._handlePalette.bind(this),
          transColor: this._handleTransColor.bind(this),
          finished: this._finished.bind(this),
          inflateData: this._inflateData.bind(this),
          simpleTransparency: this._simpleTransparency.bind(this),
          headersFinished: this._headersFinished.bind(this),
        })),
        (this._options = t),
        (this.writable = !0),
        this._parser.start()
    })
    o.inherits(e, lt),
      (e.prototype._handleError = function(t) {
        this.emit('error', t),
          (this.writable = !1),
          this.destroy(),
          this._inflate && this._inflate.destroy && this._inflate.destroy(),
          this._filter &&
            (this._filter.destroy(), this._filter.on('error', function() {})),
          (this.errord = !0)
      }),
      (e.prototype._inflateData = function(t) {
        if (!this._inflate)
          if (this._bitmapInfo.interlace)
            (this._inflate = v.createInflate()),
              this._inflate.on('error', this.emit.bind(this, 'error')),
              this._filter.on('complete', this._complete.bind(this)),
              this._inflate.pipe(this._filter)
          else {
            var e =
              (1 +
                ((this._bitmapInfo.width *
                  this._bitmapInfo.bpp *
                  this._bitmapInfo.depth +
                  7) >>
                  3)) *
              this._bitmapInfo.height
            this._inflate = v.createInflate({
              chunkSize: Math.max(e, v.Z_MIN_CHUNK),
            })
            var r = e,
              n = this.emit.bind(this, 'error')
            this._inflate.on('error', function(t) {
              r && n(t)
            }),
              this._filter.on('complete', this._complete.bind(this))
            var i = this._filter.write.bind(this._filter)
            this._inflate.on('data', function(t) {
              r && (r < t.length && (t = t.slice(0, r)), (r -= t.length), i(t))
            }),
              this._inflate.on('end', this._filter.end.bind(this._filter))
          }
        this._inflate.write(t)
      }),
      (e.prototype._handleMetaData = function(t) {
        ;(this._metaData = t),
          (this._bitmapInfo = Object.create(t)),
          (this._filter = new _t(this._bitmapInfo))
      }),
      (e.prototype._handleTransColor = function(t) {
        this._bitmapInfo.transColor = t
      }),
      (e.prototype._handlePalette = function(t) {
        this._bitmapInfo.palette = t
      }),
      (e.prototype._simpleTransparency = function() {
        this._metaData.alpha = !0
      }),
      (e.prototype._headersFinished = function() {
        this.emit('metadata', this._metaData)
      }),
      (e.prototype._finished = function() {
        this.errord ||
          (this._inflate
            ? this._inflate.end()
            : this.emit('error', 'No Inflate block'),
          this.destroySoon())
      }),
      (e.prototype._complete = function(t) {
        if (!this.errord) {
          try {
            var e = Ct(t, this._bitmapInfo),
              r = It(e, this._bitmapInfo)
            e = null
          } catch (t) {
            return void this._handleError(t)
          }
          this.emit('parsed', r)
        }
      })
  })
  var At = {
      0: function(t, e, r, n, i) {
        for (var o = 0; o < r; o++) n[i + o] = t[e + o]
      },
      1: function(t, e, r, n, i, o) {
        for (var a = 0; a < r; a++) {
          n[i + a] = t[e + a] - (a < o ? 0 : t[e + a - o])
        }
      },
      2: function(t, e, r, n, i) {
        for (var o = 0; o < r; o++) {
          n[i + o] = t[e + o] - (0 < e ? t[e + o - r] : 0)
        }
      },
      3: function(t, e, r, n, i, o) {
        for (var a = 0; a < r; a++) {
          n[i + a] =
            t[e + a] -
            (((a < o ? 0 : t[e + a - o]) + (0 < e ? t[e + a - r] : 0)) >> 1)
        }
      },
      4: function(t, e, r, n, i, o) {
        for (var a = 0; a < r; a++) {
          var s =
            t[e + a] -
            ut(
              a < o ? 0 : t[e + a - o],
              0 < e ? t[e + a - r] : 0,
              0 < e && o <= a ? t[e + a - (r + o)] : 0
            )
          n[i + a] = s
        }
      },
    },
    Lt = {
      0: function(t, e, r) {
        for (var n = 0, i = e + r, o = e; o < i; o++) n += Math.abs(t[o])
        return n
      },
      1: function(t, e, r, n) {
        for (var i = 0, o = 0; o < r; o++) {
          i += Math.abs(t[e + o] - (o < n ? 0 : t[e + o - n]))
        }
        return i
      },
      2: function(t, e, r) {
        for (var n = 0, i = e + r, o = e; o < i; o++) {
          n += Math.abs(t[o] - (0 < e ? t[o - r] : 0))
        }
        return n
      },
      3: function(t, e, r, n) {
        for (var i = 0, o = 0; o < r; o++) {
          i += Math.abs(
            t[e + o] -
              (((o < n ? 0 : t[e + o - n]) + (0 < e ? t[e + o - r] : 0)) >> 1)
          )
        }
        return i
      },
      4: function(t, e, r, n) {
        for (var i = 0, o = 0; o < r; o++) {
          var a =
            t[e + o] -
            ut(
              o < n ? 0 : t[e + o - n],
              0 < e ? t[e + o - r] : 0,
              0 < e && n <= o ? t[e + o - (r + n)] : 0
            )
          i += Math.abs(a)
        }
        return i
      },
    },
    Bt = t(function(t) {
      var e = (t.exports = function(t) {
        if (
          (((this._options = t).deflateChunkSize = t.deflateChunkSize || 32768),
          (t.deflateLevel = null != t.deflateLevel ? t.deflateLevel : 9),
          (t.deflateStrategy =
            null != t.deflateStrategy ? t.deflateStrategy : 3),
          (t.inputHasAlpha = null == t.inputHasAlpha || t.inputHasAlpha),
          (t.deflateFactory = t.deflateFactory || v.createDeflate),
          (t.bitDepth = t.bitDepth || 8),
          (t.colorType =
            'number' == typeof t.colorType
              ? t.colorType
              : vt.COLORTYPE_COLOR_ALPHA),
          (t.inputColorType =
            'number' == typeof t.inputColorType
              ? t.inputColorType
              : vt.COLORTYPE_COLOR_ALPHA),
          !~[
            vt.COLORTYPE_GRAYSCALE,
            vt.COLORTYPE_COLOR,
            vt.COLORTYPE_COLOR_ALPHA,
            vt.COLORTYPE_ALPHA,
          ].indexOf(t.colorType))
        )
          throw Error(
            'option color type:' + t.colorType + ' is not supported at present'
          )
        if (
          !~[
            vt.COLORTYPE_GRAYSCALE,
            vt.COLORTYPE_COLOR,
            vt.COLORTYPE_COLOR_ALPHA,
            vt.COLORTYPE_ALPHA,
          ].indexOf(t.inputColorType)
        )
          throw Error(
            'option input color type:' +
              t.inputColorType +
              ' is not supported at present'
          )
        if (8 !== t.bitDepth && 16 !== t.bitDepth)
          throw Error(
            'option bit depth:' + t.bitDepth + ' is not supported at present'
          )
      })
      ;(e.prototype.getDeflateOptions = function() {
        return {
          chunkSize: this._options.deflateChunkSize,
          level: this._options.deflateLevel,
          strategy: this._options.deflateStrategy,
        }
      }),
        (e.prototype.createDeflate = function() {
          return this._options.deflateFactory(this.getDeflateOptions())
        }),
        (e.prototype.filterData = function(t, e, r) {
          return (function(t, e, r, n, i) {
            var o
            if ('filterType' in n && -1 !== n.filterType) {
              if ('number' != typeof n.filterType)
                throw Error('unrecognised filter types')
              o = [n.filterType]
            } else o = [0, 1, 2, 3, 4]
            16 === n.bitDepth && (i *= 2)
            for (
              var a = e * i,
                s = 0,
                h = 0,
                u = new Buffer((1 + a) * r),
                f = o[0],
                l = 0;
              l < r;
              l++
            ) {
              if (1 < o.length)
                for (var c = 1 / 0, d = 0; d < o.length; d++) {
                  var p = Lt[o[d]](t, h, a, i)
                  p < c && ((f = o[d]), (c = p))
                }
              At[(u[s] = f)](t, h, a, u, ++s, i), (s += a), (h += a)
            }
            return u
          })(
            (function(t, e, r, i) {
              var n,
                o = !!~[vt.COLORTYPE_COLOR_ALPHA, vt.COLORTYPE_ALPHA].indexOf(
                  i.colorType
                )
              if (i.colorType === i.inputColorType) {
                var a = ((n = new ArrayBuffer(2)),
                new DataView(n).setInt16(0, 256, !0),
                256 !== new Int16Array(n)[0])
                if (8 === i.bitDepth || (16 === i.bitDepth && a)) return t
              }
              var s = 16 !== i.bitDepth ? t : new Uint16Array(t.buffer),
                h = 255,
                u = vt.COLORTYPE_TO_BPP_MAP[i.inputColorType]
              4 !== u || i.inputHasAlpha || (u = 3)
              var f = vt.COLORTYPE_TO_BPP_MAP[i.colorType]
              16 === i.bitDepth && ((h = 65535), (f *= 2))
              var l = new Buffer(e * r * f),
                c = 0,
                d = 0,
                p = i.bgColor || {}
              function g() {
                var t,
                  e,
                  r,
                  n = h
                switch (i.inputColorType) {
                  case vt.COLORTYPE_COLOR_ALPHA:
                    ;(n = s[c + 3]), (t = s[c]), (e = s[c + 1]), (r = s[c + 2])
                    break
                  case vt.COLORTYPE_COLOR:
                    ;(t = s[c]), (e = s[c + 1]), (r = s[c + 2])
                    break
                  case vt.COLORTYPE_ALPHA:
                    ;(n = s[c + 1]), (r = e = t = s[c])
                    break
                  case vt.COLORTYPE_GRAYSCALE:
                    r = e = t = s[c]
                    break
                  default:
                    throw Error(
                      'input color type:' +
                        i.inputColorType +
                        ' is not supported at present'
                    )
                }
                return (
                  i.inputHasAlpha &&
                    (o ||
                      ((t = Math.min(
                        Math.max(Math.round((1 - (n /= h)) * p.red + n * t), 0),
                        h
                      )),
                      (e = Math.min(
                        Math.max(Math.round((1 - n) * p.green + n * e), 0),
                        h
                      )),
                      (r = Math.min(
                        Math.max(Math.round((1 - n) * p.blue + n * r), 0),
                        h
                      )))),
                  { red: t, green: e, blue: r, alpha: n }
                )
              }
              void 0 === p.red && (p.red = h),
                void 0 === p.green && (p.green = h),
                void 0 === p.blue && (p.blue = h)
              for (var _ = 0; _ < r; _++)
                for (var v = 0; v < e; v++) {
                  var m = g()
                  switch (i.colorType) {
                    case vt.COLORTYPE_COLOR_ALPHA:
                    case vt.COLORTYPE_COLOR:
                      8 === i.bitDepth
                        ? ((l[d] = m.red),
                          (l[d + 1] = m.green),
                          (l[d + 2] = m.blue),
                          o && (l[d + 3] = m.alpha))
                        : (l.writeUInt16BE(m.red, d),
                          l.writeUInt16BE(m.green, d + 2),
                          l.writeUInt16BE(m.blue, d + 4),
                          o && l.writeUInt16BE(m.alpha, d + 6))
                      break
                    case vt.COLORTYPE_ALPHA:
                    case vt.COLORTYPE_GRAYSCALE:
                      var y = (m.red + m.green + m.blue) / 3
                      8 === i.bitDepth
                        ? ((l[d] = y), o && (l[d + 1] = m.alpha))
                        : (l.writeUInt16BE(y, d),
                          o && l.writeUInt16BE(m.alpha, d + 2))
                      break
                    default:
                      throw Error('unrecognised color Type ' + i.colorType)
                  }
                  ;(c += u), (d += f)
                }
              return l
            })(t, e, r, this._options),
            e,
            r,
            this._options,
            vt.COLORTYPE_TO_BPP_MAP[this._options.colorType]
          )
        }),
        (e.prototype._packChunk = function(t, e) {
          var r = e ? e.length : 0,
            n = new Buffer(r + 12)
          return (
            n.writeUInt32BE(r, 0),
            n.writeUInt32BE(t, 4),
            e && e.copy(n, 8),
            n.writeInt32BE(mt.crc32(n.slice(4, n.length - 4)), n.length - 4),
            n
          )
        }),
        (e.prototype.packGAMA = function(t) {
          var e = new Buffer(4)
          return (
            e.writeUInt32BE(Math.floor(t * vt.GAMMA_DIVISION), 0),
            this._packChunk(vt.TYPE_gAMA, e)
          )
        }),
        (e.prototype.packIHDR = function(t, e) {
          var r = new Buffer(13)
          return (
            r.writeUInt32BE(t, 0),
            r.writeUInt32BE(e, 4),
            (r[8] = this._options.bitDepth),
            (r[9] = this._options.colorType),
            (r[10] = 0),
            (r[11] = 0),
            (r[12] = 0),
            this._packChunk(vt.TYPE_IHDR, r)
          )
        }),
        (e.prototype.packIDAT = function(t) {
          return this._packChunk(vt.TYPE_IDAT, t)
        }),
        (e.prototype.packIEND = function() {
          return this._packChunk(vt.TYPE_IEND, null)
        })
    }),
    Rt = t(function(t) {
      var e = (t.exports = function(t) {
        r.call(this),
          (this._packer = new Bt(t || {})),
          (this._deflate = this._packer.createDeflate()),
          (this.readable = !0)
      })
      o.inherits(e, r),
        (e.prototype.pack = function(t, e, r, n) {
          this.emit('data', new Buffer(vt.PNG_SIGNATURE)),
            this.emit('data', this._packer.packIHDR(e, r)),
            n && this.emit('data', this._packer.packGAMA(n))
          var i = this._packer.filterData(t, e, r)
          this._deflate.on('error', this.emit.bind(this, 'error')),
            this._deflate.on(
              'data',
              function(t) {
                this.emit('data', this._packer.packIDAT(t))
              }.bind(this)
            ),
            this._deflate.on(
              'end',
              function() {
                this.emit('data', this._packer.packIEND()), this.emit('end')
              }.bind(this)
            ),
            this._deflate.end(i)
        })
    }),
    Ot = t(function(t, e) {
      var p = a.ok,
        g = i.kMaxLength
      function r(t) {
        if (!(this instanceof r)) return new r(t)
        t && t.chunkSize < v.Z_MIN_CHUNK && (t.chunkSize = v.Z_MIN_CHUNK),
          v.Inflate.call(this, t),
          (this._offset =
            void 0 === this._offset ? this._outOffset : this._offset),
          (this._buffer = this._buffer || this._outBuffer),
          t && null != t.maxLength && (this._maxLength = t.maxLength)
      }
      function _(t, e) {
        e && process.nextTick(e),
          t._handle && (t._handle.close(), (t._handle = null))
      }
      function n(t, e) {
        return (function(t, e) {
          if (
            ('string' == typeof e && (e = Buffer.from(e)),
            !(e instanceof Buffer))
          )
            throw new TypeError('Not a string or buffer')
          var r = t._finishFlushFlag
          return null == r && (r = v.Z_FINISH), t._processChunk(e, r)
        })(new r(e), t)
      }
      ;(r.prototype._processChunk = function(t, e, r) {
        if ('function' == typeof r)
          return v.Inflate._processChunk.call(this, t, e, r)
        var n,
          i = this,
          o = t && t.length,
          a = this._chunkSize - this._offset,
          s = this._maxLength,
          h = 0,
          u = [],
          f = 0
        function l(t, e) {
          if (!i._hadError) {
            var r = a - e
            if ((p(0 <= r, 'have should not go down'), 0 < r)) {
              var n = i._buffer.slice(i._offset, i._offset + r)
              if (
                ((i._offset += r),
                s < n.length && (n = n.slice(0, s)),
                u.push(n),
                (f += n.length),
                0 === (s -= n.length))
              )
                return !1
            }
            return (
              (0 !== e && i._offset < i._chunkSize) ||
                ((a = i._chunkSize),
                (i._offset = 0),
                (i._buffer = Buffer.allocUnsafe(i._chunkSize))),
              0 === e && ((h += o - t), (o = t), !0)
            )
          }
        }
        this.on('error', function(t) {
          n = t
        }),
          p(this._handle, 'zlib binding closed')
        do {
          var c = this._handle.writeSync(
            e,
            t,
            h,
            o,
            this._buffer,
            this._offset,
            a
          )
          c = c || this._writeState
        } while (!this._hadError && l(c[0], c[1]))
        if (this._hadError) throw n
        if (g <= f)
          throw (_(this),
          new RangeError(
            'Cannot create final Buffer. It would be larger than 0x' +
              g.toString(16) +
              ' bytes'
          ))
        var d = Buffer.concat(u, f)
        return _(this), d
      }),
        o.inherits(r, v.Inflate),
        (t.exports = e = n),
        (e.Inflate = r),
        (e.createInflate = function(t) {
          return new r(t)
        }),
        (e.inflateSync = n)
    }),
    kt = t(function(t) {
      var e = (t.exports = function(t) {
        ;(this._buffer = t), (this._reads = [])
      })
      ;(e.prototype.read = function(t, e) {
        this._reads.push({ length: Math.abs(t), allowLess: t < 0, func: e })
      }),
        (e.prototype.process = function() {
          for (; 0 < this._reads.length && this._buffer.length; ) {
            var t = this._reads[0]
            if (
              !this._buffer.length ||
              (this._buffer.length < t.length && !t.allowLess)
            )
              break
            this._reads.shift()
            var e = this._buffer
            ;(this._buffer = e.slice(t.length)),
              t.func.call(this, e.slice(0, t.length))
          }
          return 0 < this._reads.length
            ? Error('There are some read requests waitng on finished stream')
            : 0 < this._buffer.length
            ? Error('unrecognised content at end of stream')
            : void 0
        })
    }),
    Mt = function(t, e) {
      var r = [],
        n = new kt(t)
      return (
        new gt(e, {
          read: n.read.bind(n),
          write: function(t) {
            r.push(t)
          },
          complete: function() {},
        }).start(),
        n.process(),
        Buffer.concat(r)
      )
    },
    Nt = !0
  v.deflateSync || (Nt = !1)
  var Dt = !0
  v.deflateSync || (Dt = !1)
  var xt = {
      read: function(t, e) {
        return (function(t, e) {
          if (!Nt)
            throw Error(
              'To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0'
            )
          var r, n, i
          var o = []
          var a = new kt(t)
          if (
            (new yt(e, {
              read: a.read.bind(a),
              error: function(t) {
                r = t
              },
              metadata: function(t) {
                n = t
              },
              gamma: function(t) {
                i = t
              },
              palette: function(t) {
                n.palette = t
              },
              transColor: function(t) {
                n.transColor = t
              },
              inflateData: function(t) {
                o.push(t)
              },
              simpleTransparency: function() {
                n.alpha = !0
              },
            }).start(),
            a.process(),
            r)
          )
            throw r
          var s,
            h = Buffer.concat(o)
          if (((o.length = 0), n.interlace)) s = v.inflateSync(h)
          else {
            var u = (1 + ((n.width * n.bpp * n.depth + 7) >> 3)) * n.height
            s = Ot(h, { chunkSize: u, maxLength: u })
          }
          if (((h = null), !s || !s.length))
            throw Error('bad png - invalid inflate data response')
          var f = Mt(s, n)
          h = null
          var l = Ct(f, n)
          f = null
          var c = It(l, n)
          return (n.data = c), (n.gamma = i || 0), n
        })(t, e || {})
      },
      write: function(t, e) {
        return (function(t, e) {
          if (!Dt)
            throw Error(
              'To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0'
            )
          var r = new Bt(e || {}),
            n = []
          n.push(new Buffer(vt.PNG_SIGNATURE)),
            n.push(r.packIHDR(t.width, t.height)),
            t.gamma && n.push(r.packGAMA(t.gamma))
          var i = r.filterData(t.data, t.width, t.height),
            o = v.deflateSync(i, r.getDeflateOptions())
          if (((i = null), !o || !o.length))
            throw Error('bad png - invalid compressed data response')
          return n.push(r.packIDAT(o)), n.push(r.packIEND()), Buffer.concat(n)
        })(t, e)
      },
    },
    St = t(function(t, e) {
      var s = (e.PNG = function(t) {
        r.call(this),
          (this.width = 0 | (t = t || {}).width),
          (this.height = 0 | t.height),
          (this.data =
            0 < this.width && 0 < this.height
              ? new Buffer(4 * this.width * this.height)
              : null),
          t.fill && this.data && this.data.fill(0),
          (this.gamma = 0),
          (this.readable = this.writable = !0),
          (this._parser = new Pt(t)),
          this._parser.on('error', this.emit.bind(this, 'error')),
          this._parser.on('close', this._handleClose.bind(this)),
          this._parser.on('metadata', this._metadata.bind(this)),
          this._parser.on('gamma', this._gamma.bind(this)),
          this._parser.on(
            'parsed',
            function(t) {
              ;(this.data = t), this.emit('parsed', t)
            }.bind(this)
          ),
          (this._packer = new Rt(t)),
          this._packer.on('data', this.emit.bind(this, 'data')),
          this._packer.on('end', this.emit.bind(this, 'end')),
          this._parser.on('close', this._handleClose.bind(this)),
          this._packer.on('error', this.emit.bind(this, 'error'))
      })
      o.inherits(s, r),
        (s.sync = xt),
        (s.prototype.pack = function() {
          return (
            this.data && this.data.length
              ? process.nextTick(
                  function() {
                    this._packer.pack(
                      this.data,
                      this.width,
                      this.height,
                      this.gamma
                    )
                  }.bind(this)
                )
              : this.emit('error', 'No data provided'),
            this
          )
        }),
        (s.prototype.parse = function(t, e) {
          var r, n
          e &&
            ((r = function(t) {
              this.removeListener('error', n), (this.data = t), e(null, this)
            }.bind(this)),
            (n = function(t) {
              this.removeListener('parsed', r), e(t, null)
            }.bind(this)),
            this.once('parsed', r),
            this.once('error', n))
          return this.end(t), this
        }),
        (s.prototype.write = function(t) {
          return this._parser.write(t), !0
        }),
        (s.prototype.end = function(t) {
          this._parser.end(t)
        }),
        (s.prototype._metadata = function(t) {
          ;(this.width = t.width),
            (this.height = t.height),
            this.emit('metadata', t)
        }),
        (s.prototype._gamma = function(t) {
          this.gamma = t
        }),
        (s.prototype._handleClose = function() {
          this._parser.writable || this._packer.readable || this.emit('close')
        }),
        (s.bitblt = function(t, e, r, n, i, o, a, s) {
          if (
            ((n |= 0),
            (i |= 0),
            (o |= 0),
            (a |= 0),
            (s |= 0),
            t.width < (r |= 0) ||
              t.height < n ||
              t.width < r + i ||
              t.height < n + o)
          )
            throw Error('bitblt reading outside image')
          if (
            e.width < a ||
            e.height < s ||
            e.width < a + i ||
            e.height < s + o
          )
            throw Error('bitblt writing outside image')
          for (var h = 0; h < o; h++)
            t.data.copy(
              e.data,
              ((s + h) * e.width + a) << 2,
              ((n + h) * t.width + r) << 2,
              ((n + h) * t.width + r + i) << 2
            )
        }),
        (s.prototype.bitblt = function(t, e, r, n, i, o, a) {
          return s.bitblt(this, t, e, r, n, i, o, a), this
        }),
        (s.adjustGamma = function(t) {
          if (t.gamma) {
            for (var e = 0; e < t.height; e++)
              for (var r = 0; r < t.width; r++)
                for (var n = (t.width * e + r) << 2, i = 0; i < 3; i++) {
                  var o = t.data[n + i] / 255
                  t.data[n + i] = Math.round(
                    255 * (o = Math.pow(o, 1 / 2.2 / t.gamma))
                  )
                }
            t.gamma = 0
          }
        }),
        (s.prototype.adjustGamma = function() {
          s.adjustGamma(this)
        })
    }),
    Yt = t(function(t, d) {
      function r(t) {
        if (('number' == typeof t && (t = '' + t), 'string' != typeof t))
          throw Error('Color should be defined as hex string')
        var e = t
          .slice()
          .replace('#', '')
          .split('')
        if (e.length < 3 || 5 === e.length || 8 < e.length)
          throw Error('Invalid hex color: ' + t)
        ;(3 !== e.length && 4 !== e.length) ||
          (e = Array.prototype.concat.apply(
            [],
            e.map(function(t) {
              return [t, t]
            })
          )),
          6 === e.length && e.push('F', 'F')
        var r = parseInt(e.join(''), 16)
        return {
          r: (r >> 24) & 255,
          g: (r >> 16) & 255,
          b: (r >> 8) & 255,
          a: 255 & r,
          hex: '#' + e.slice(0, 6).join(''),
        }
      }
      ;(d.getOptions = function(t) {
        ;(t = t || {}).color || (t.color = {})
        var e = t.width && 21 <= t.width ? t.width : void 0
        return {
          width: e,
          scale: e ? 4 : t.scale || 4,
          margin: null == t.margin || t.margin < 0 ? 4 : t.margin,
          color: {
            dark: r(t.color.dark || '#000000ff'),
            light: r(t.color.light || '#ffffffff'),
          },
          type: t.type,
          rendererOpts: t.rendererOpts || {},
        }
      }),
        (d.getScale = function(t, e) {
          return e.width && t + 2 * e.margin <= e.width
            ? e.width / (t + 2 * e.margin)
            : e.scale
        }),
        (d.getImageWidth = function(t, e) {
          var r = d.getScale(t, e)
          return Math.floor((t + 2 * e.margin) * r)
        }),
        (d.qrToImageData = function(t, e, r) {
          for (
            var n = e.modules.size,
              i = e.modules.data,
              o = d.getScale(n, r),
              a = Math.floor((n + 2 * r.margin) * o),
              s = r.margin * o,
              h = [r.color.light, r.color.dark],
              u = 0;
            u < a;
            u++
          )
            for (var f = 0; f < a; f++) {
              var l = 4 * (u * a + f),
                c = r.color.light
              if (s <= u && s <= f && u < a - s && f < a - s)
                c =
                  h[
                    i[Math.floor((u - s) / o) * n + Math.floor((f - s) / o)]
                      ? 1
                      : 0
                  ]
              ;(t[l++] = c.r), (t[l++] = c.g), (t[l++] = c.b), (t[l] = c.a)
            }
        })
    }),
    Ut = t(function(t, o) {
      var a = St.PNG
      ;(o.render = function(t, e) {
        var r = Yt.getOptions(e),
          n = r.rendererOpts,
          i = Yt.getImageWidth(t.modules.size, r)
        ;(n.width = i), (n.height = i)
        var o = new a(n)
        return Yt.qrToImageData(o.data, t, r), o
      }),
        (o.renderToDataURL = function(t, e, n) {
          void 0 === n && ((n = e), (e = void 0)),
            o.renderToBuffer(t, e, function(t, e) {
              t && n(t)
              var r = 'data:image/png;base64,'
              n(null, (r += e.toString('base64')))
            })
        }),
        (o.renderToBuffer = function(t, e, r) {
          void 0 === r && ((r = e), (e = void 0))
          var n = o.render(t, e),
            i = []
          n.on('error', r),
            n.on('data', function(t) {
              i.push(t)
            }),
            n.on('end', function() {
              r(null, Buffer.concat(i))
            }),
            n.pack()
        }),
        (o.renderToFile = function(t, e, r, n) {
          void 0 === n && ((n = r), (r = void 0))
          var i = s.createWriteStream(t)
          i.on('error', n), i.on('close', n), o.renderToFileStream(i, e, r)
        }),
        (o.renderToFileStream = function(t, e, r) {
          o.render(e, r)
            .pack()
            .pipe(t)
        })
    }),
    Ht = t(function(t, a) {
      var g = { WW: ' ', WB: 'â', BB: 'â', BW: 'â' },
        _ = { BB: ' ', BW: 'â', WW: 'â', WB: 'â' }
      ;(a.render = function(t, e, r) {
        var n = Yt.getOptions(e),
          i = g
        ;('#ffffff' !== n.color.dark.hex && '#000000' !== n.color.light.hex) ||
          (i = _)
        var o = t.modules.size,
          a = t.modules.data,
          s = '',
          h = Array(o + 2 * n.margin + 1).join(i.WW)
        h = Array(n.margin / 2 + 1).join(h + '\n')
        var u,
          f,
          l,
          c = Array(n.margin + 1).join(i.WW)
        s += h
        for (var d = 0; d < o; d += 2) {
          s += c
          for (var p = 0; p < o; p++) {
            s += ((f = a[(d + 1) * o + p]),
            (l = i),
            (u = a[d * o + p]) && f
              ? l.BB
              : u && !f
              ? l.BW
              : !u && f
              ? l.WB
              : l.WW)
          }
          s += c + '\n'
        }
        return (s += h.slice(0, -1)), 'function' == typeof r && r(null, s), s
      }),
        (a.renderToFile = function(t, e, r, n) {
          void 0 === n && ((n = r), (r = void 0))
          var i = s,
            o = a.render(e, r)
          i.writeFile(t, o, n)
        })
    }),
    Ft = {
      render: function(t, e, r) {
        var n = t.modules.size,
          i = t.modules.data,
          o = '[47m  [0m',
          a = '',
          s = Array(n + 3).join(o)
        a += s + '\n'
        for (var h = 0; h < n; ++h) {
          a += o
          for (var u = 0; u < n; u++) a += i[h * n + u] ? '[40m  [0m' : o
          a += '[47m  [0m\n'
        }
        return (a += s + '\n'), 'function' == typeof r && r(null, a), a
      },
    }
  function zt(t, e) {
    var r = t.a / 255,
      n = e + '="' + t.hex + '"'
    return r < 1 ? n + ' ' + e + '-opacity="' + r.toFixed(2).slice(1) + '"' : n
  }
  function Gt(t, e, r) {
    var n = t + e
    return void 0 !== r && (n += ' ' + r), n
  }
  var Wt = function(t, e, r) {
      var n = Yt.getOptions(e),
        i = t.modules.size,
        o = t.modules.data,
        a = i + 2 * n.margin,
        s = n.color.light.a
          ? '<path ' +
            zt(n.color.light, 'fill') +
            ' d="M0 0h' +
            a +
            'v' +
            a +
            'H0z"/>'
          : '',
        h =
          '<path ' +
          zt(n.color.dark, 'stroke') +
          ' d="' +
          (function(t, e, r) {
            for (var n = '', i = 0, o = !1, a = 0, s = 0; s < t.length; s++) {
              var h = Math.floor(s % e)
              h || o || (o = !0),
                t[s]
                  ? (a++,
                    (0 < s && 0 < h && t[s - 1]) ||
                      ((n += o
                        ? Gt('M', h + r, 0.5 + Math.floor(s / e) + r)
                        : Gt('m', i, 0)),
                      (i = 0),
                      (o = !1)),
                    (1 + h < e && t[s + 1]) || ((n += Gt('h', a)), (a = 0)))
                  : i++
            }
            return n
          })(o, i, n.margin) +
          '"/>',
        u =
          '<svg xmlns="http://www.w3.org/2000/svg" ' +
          (n.width ? 'width="' + n.width + '" height="' + n.width + '" ' : '') +
          ('viewBox="0 0 ' + a + ' ' + a + '"') +
          ' shape-rendering="crispEdges">' +
          s +
          h +
          '</svg>\n'
      return 'function' == typeof r && r(null, u), u
    },
    qt = t(function(t, a) {
      ;(a.render = Wt),
        (a.renderToFile = function(t, e, r, n) {
          void 0 === n && ((n = r), (r = void 0))
          var i = s,
            o = a.render(e, r)
          i.writeFile(
            t,
            '<?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">' +
              o,
            n
          )
        })
    }),
    jt = t(function(t, i) {
      ;(i.render = function(t, e, r) {
        var n = r,
          i = e
        void 0 !== n || (e && e.getContext) || ((n = e), (e = void 0)),
          e ||
            (i = (function() {
              try {
                return document.createElement('canvas')
              } catch (t) {
                throw Error('You need to specify a canvas element')
              }
            })()),
          (n = Yt.getOptions(n))
        var o = Yt.getImageWidth(t.modules.size, n),
          a = i.getContext('2d'),
          s = a.createImageData(o, o)
        return (
          Yt.qrToImageData(s.data, t, n),
          (function(t, e, r) {
            t.clearRect(0, 0, e.width, e.height),
              e.style || (e.style = {}),
              (e.height = r),
              (e.width = r),
              (e.style.height = r + 'px'),
              (e.style.width = r + 'px')
          })(a, i, o),
          a.putImageData(s, 0, 0),
          i
        )
      }),
        (i.renderToDataURL = function(t, e, r) {
          var n = r
          return (
            void 0 !== n || (e && e.getContext) || ((n = e), (e = void 0)),
            i
              .render(t, e, (n = n || {}))
              .toDataURL(n.type || 'image/png', (n.rendererOpts || {}).quality)
          )
        })
    })
  function Kt(n, i, o, a, e) {
    var t = [].slice.call(arguments, 1),
      r = t.length,
      s = 'function' == typeof t[r - 1]
    if (!s && !u()) throw Error('Callback required as last argument')
    if (!s) {
      if (r < 1) throw Error('Too few arguments provided')
      return (
        1 === r
          ? ((o = i), (i = a = void 0))
          : 2 !== r || i.getContext || ((a = o), (o = i), (i = void 0)),
        new Promise(function(t, e) {
          try {
            var r = ft(o, a)
            t(n(r, i, a))
          } catch (t) {
            e(t)
          }
        })
      )
    }
    if (r < 2) throw Error('Too few arguments provided')
    2 === r
      ? ((e = o), (o = i), (i = a = void 0))
      : 3 === r &&
        (i.getContext && void 0 === e
          ? ((e = a), (a = void 0))
          : ((e = a), (a = o), (o = i), (i = void 0)))
    try {
      var h = ft(o, a)
      e(null, n(h, i, a))
    } catch (t) {
      e(t)
    }
  }
  var Jt = ft,
    Vt = Kt.bind(null, jt.render),
    Qt = Kt.bind(null, jt.renderToDataURL),
    $t = Kt.bind(null, function(t, e, r) {
      return Wt(t, r)
    })
  function Zt(t, e, r) {
    if (void 0 === t) throw Error('String required as first argument')
    if ((void 0 === r && ((r = e), (e = {})), 'function' != typeof r)) {
      if (!u()) throw Error('Callback required as last argument')
      ;(e = r || {}), (r = null)
    }
    return { opts: e, cb: r }
  }
  function Xt(t) {
    switch (t) {
      case 'svg':
        return qt
      case 'txt':
      case 'utf8':
        return Ht
      case 'png':
      case 'image/png':
      default:
        return Ut
    }
  }
  function te(e, i, o) {
    if (!o.cb)
      return new Promise(function(r, n) {
        try {
          var t = ft(i, o.opts)
          return e(t, o.opts, function(t, e) {
            return t ? n(t) : r(e)
          })
        } catch (t) {
          n(t)
        }
      })
    try {
      var t = ft(i, o.opts)
      return e(t, o.opts, o.cb)
    } catch (t) {
      o.cb(t)
    }
  }
  var ee = {
    create: ft,
    toCanvas: { create: Jt, toCanvas: Vt, toDataURL: Qt, toString: $t }
      .toCanvas,
    toString: function(t, e, r) {
      var n = Zt(t, e, r)
      return te(
        (function(t) {
          switch (t) {
            case 'svg':
              return qt
            case 'terminal':
              return Ft
            case 'utf8':
            default:
              return Ht
          }
        })(n.opts.type).render,
        t,
        n
      )
    },
    toDataURL: function(t, e, r) {
      var n = Zt(t, e, r)
      return te(Xt(n.opts.type).renderToDataURL, t, n)
    },
    toBuffer: function(t, e, r) {
      var n = Zt(t, e, r)
      return te(Xt(n.opts.type).renderToBuffer, t, n)
    },
    toFile: function(t, e, r, n) {
      if (
        'string' != typeof t ||
        ('string' != typeof e && 'object' != typeof e)
      )
        throw Error('Invalid argument')
      if (arguments.length < 3 && !u())
        throw Error('Too few arguments provided')
      var i = Zt(e, r, n)
      return te(
        Xt(
          i.opts.type ||
            (function(t) {
              return t.slice(2 + ((t.lastIndexOf('.') - 1) >>> 0)).toLowerCase()
            })(t)
        ).renderToFile.bind(null, t),
        e,
        i
      )
    },
    toFileStream: function(t, e, r) {
      if (arguments.length < 2) throw Error('Too few arguments provided')
      var n = Zt(e, r, t.emit.bind(t, 'error'))
      te(Xt('png').renderToFileStream.bind(null, t), e, n)
    },
  }
  Object.freeze({ default: ee, __moduleExports: ee })
  return {
    render: function(t) {
      var e = this.size
      return t(
        'div',
        {
          class: this.className,
          attrs: {
            value: this.value,
            level: this.level,
            background: this.background,
            foreground: this.foreground,
          },
        },
        [
          t(
            'canvas',
            {
              attrs: { height: e, width: e },
              style: { width: e + 'px', height: e + 'px' },
              ref: 'qrcode-vue',
            },
            []
          ),
        ]
      )
    },
    props: {
      value: { type: void 0, required: !0 },
      className: { type: String, default: '' },
      size: {
        type: [Number, String],
        default: 100,
        validator: function(t) {
          return !0 !== isNaN(+t)
        },
      },
      level: {
        type: String,
        default: 'L',
        validator: function(t) {
          return !!~['L', 'Q', 'M', 'H'].indexOf(t)
        },
      },
      background: { type: String, default: '#fff' },
      foreground: { type: String, default: '#000' },
    },
    methods: {
      render: function() {
        ;(void 0)(
          this.$refs['qrcode-vue'],
          this.value,
          {
            errorCorrectionLevel: this.level,
            width: this.size >>> 0,
            color: { dark: this.background, light: this.foreground },
          },
          function(t) {
            if (t) throw t
          }
        )
      },
    },
    updated: function() {
      this.render()
    },
    mounted: function() {
      this.render()
    },
  }
})
